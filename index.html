<html>
<head>
  <title>CS32310 - Assignment</title>
  
  <link rel="stylesheet" type="text/css" href="css/style.css">

  <script src="js/build/three.min.js"></script>
  <script src="js/build/PointerLockControls.js"></script>
  <script src="js/build/DDSLoader.js"></script>
  <script src="js/build/MTLLoader.js"></script>
  <script src="js/build/OBJLoader.js"></script>
  <script src="js/build/Cloth.js"></script>
  
  <!-- The remaining scripts are taken from Three.js examples and used for various particle effects -->
  <script type="x-shader/x-vertex" id="vertexshader"> attribute float size; attribute vec3 customColor; varying vec3 vColor; void main() { vColor = customColor; vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 ); gl_PointSize = size * ( 300.0 / -mvPosition.z ); gl_Position = projectionMatrix * mvPosition; } </script>
  <script type="x-shader/x-fragment" id="fragmentshader"> uniform vec3 color; uniform sampler2D texture; varying vec3 vColor; void main() { gl_FragColor = vec4( color * vColor, 1.0 ); gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord ); } </script>
  <script type="x-shader/x-fragment" id="fragmentShaderDepth"> #include    <packing> uniform sampler2D texture; varying vec2 vUV; void main() { vec4 pixel = texture2D( texture, vUV ); if ( pixel.a < 0.5 ) discard; gl_FragData[ 0 ]=p ackDepthToRGBA( gl_FragCoord.z ); }
  </script>
  <script type="x-shader/x-vertex" id="vertexShaderDepth"> varying vec2 vUV; void main() { vUV = 0.75 * uv; vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 ); gl_Position = projectionMatrix * mvPosition; }
  </script>
</head>

<body>
  <div id="blocker">
    <div id="instructions"> <span style="font-size:40px">Click to look around</span>
      <br/> (W, A, S, D = Move, SPACE = Interact, MOUSE = Look around, ESC = pause) </div>
  </div>
  <script>
    var width = window.innerWidth;
    var height = window.innerHeight;
    var INTERACT = false;
    //pointerlock controls
    /**
     * PointerLock controls based largely on the Three.js
     * example, taken from: https://threejs.org/examples/#misc_controls_pointerlock
     * adapted by me, Leon Hassan - leh28
     */
    var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;
    if (havePointerLock) {
      var element = document.body;
      var pointerlockchange = function (event) {
        if (document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element) {
          controlsEnabled = true;
          controls.enabled = true;
          blocker.style.display = 'none';
        } else {
          controls.enabled = false;
          blocker.style.display = '-webkit-box';
          blocker.style.display = '-moz-box';
          blocker.style.display = 'box';
          instructions.style.display = '';
        }
      };
      var pointerlockerror = function (event) {
        instructions.style.display = '';
      };
      // Hook pointer lock state change events
      document.addEventListener('pointerlockchange', pointerlockchange, false);
      document.addEventListener('mozpointerlockchange', pointerlockchange, false);
      document.addEventListener('webkitpointerlockchange', pointerlockchange, false);
      document.addEventListener('pointerlockerror', pointerlockerror, false);
      document.addEventListener('mozpointerlockerror', pointerlockerror, false);
      document.addEventListener('webkitpointerlockerror', pointerlockerror, false);
      instructions.addEventListener('click', function (event) {
        instructions.style.display = 'none';
        // Ask the browser to lock the pointer
        element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
        if (/Firefox/i.test(navigator.userAgent)) {
          var fullscreenchange = function (event) {
            if (document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element) {
              document.removeEventListener('fullscreenchange', fullscreenchange);
              document.removeEventListener('mozfullscreenchange', fullscreenchange);
              element.requestPointerLock();
            }
          };
          document.addEventListener('fullscreenchange', fullscreenchange, false);
          document.addEventListener('mozfullscreenchange', fullscreenchange, false);
          element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;
          element.requestFullscreen();
        } else {
          element.requestPointerLock();
        }
      }, false);
    } else {
      instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
    }
    var moveLeft = false;
    var moveRight = false;
    var moveForward = false;
    var moveBackward = false;
    var controlsEnabled = false;
    var objects = [];
    var prevTime = performance.now();
    var velocity = new THREE.Vector3();
    document.addEventListener("mousemove", this.moveCallback, false);
    var renderer = new THREE.WebGLRenderer({
      antialias: true
    });
    renderer.setSize(width, height);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFShadowMap;
    renderer.shadowMapSoft = false;
    document.body.appendChild(renderer.domElement);
    // define the scene 			
    var scene = new THREE.Scene();
    //Add an axis to center of the screen
    var axis = new THREE.AxisHelper(10);
    scene.add(axis);
    // define the camera from which the scene will be rendered and seen
    var camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
    //add controls
    var controls = new THREE.PointerLockControls(camera);
    //spawn outside front door, facing the door
    controls.getObject().position.set(10, 5, 130);
    controls.getObject().rotation.y = (Math.PI * (90 / 180));
    //key listeners 
    var onKeyDown = function (event) {
      switch (event.keyCode) {
      case 38: // up
      case 87: // w
        moveForward = true;
        break;
      case 37: // left
      case 65: // a
        moveLeft = true;
        break;
      case 40: // down
      case 83: // s
        moveBackward = true;
        break;
      case 39: // right
      case 68: // d
        moveRight = true;
        break;
      case 32: // space
        break;
      case 27: // esc
        break;
      }
    };
    var onKeyUp = function (event) {
      switch (event.keyCode) {
      case 38: // up
      case 87: // w
        moveForward = false;
        break;
      case 37: // left
      case 65: // a
        moveLeft = false;
        break;
      case 40: // down
      case 83: // s
        moveBackward = false;
        break;
      case 39: // right
      case 68: // d
        moveRight = false;
        break;
      case 32:
        INTERACT = true;
        //trigger global interact switch
        break;
      case 27: // esc
        //stop controls
        controlsEnabled = false;
        break;
      }
    };
    //add listeners so we can capture keypress events
    document.addEventListener('keydown', onKeyDown, false);
    document.addEventListener('keyup', onKeyUp, false);
    //fire particles
    /**
     * buffergeometry particles based largely on the Three.js
     * example, taken from: https://threejs.org/examples/#webgl_buffergeometry_custom_attributes_particles
     * adapted by me, Leon Hassan - leh28
     */
    var particles = 50;
    var radius = 3;
    var uniforms = {
      color: {
        value: new THREE.Color(0xff0000) //0xff6633 = orange, 0xE5E500 = yellow
      },
      texture: {
        //texture taken from example, cited above
        value: new THREE.TextureLoader().load("tex/spark.png")
      }
    };
    var shaderMaterial = new THREE.ShaderMaterial({
      uniforms: uniforms,
      vertexShader: document.getElementById('vertexshader').textContent,
      fragmentShader: document.getElementById('fragmentshader').textContent,
      blending: THREE.AdditiveBlending,
      /*depthTest: false,*/
      transparent: true
    });
    geometry = new THREE.BufferGeometry();
    var positions = new Float32Array(particles * 3);
    var colors = new Float32Array(particles * 3);
    var sizes = new Float32Array(particles);
    var color = new THREE.Color();
    for (var i = 0, i3 = 0; i < particles; i++, i3 += 3) {
      positions[i3 + 0] = (Math.random() * 2 - 1) * radius;
      positions[i3 + 1] = (Math.random() * 2 - 1) * radius;
      positions[i3 + 2] = (Math.random() * 2 - 1) * radius;
      color.setHSL(i / particles, 1.0, 0.5);
      colors[i3 + 0] = color.r;
      colors[i3 + 1] = color.g;
      colors[i3 + 2] = color.b;
      sizes[i] = 5;
    }
    geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.addAttribute('customColor', new THREE.BufferAttribute(colors, 3));
    geometry.addAttribute('size', new THREE.BufferAttribute(sizes, 1));
    var particleSystem = new THREE.Points(geometry, shaderMaterial);
    particleSystem.position.set(5, 7, -92.5);
    scene.add(particleSystem);
    //Raycaster
    /**
     * Raycasting based on the Three.js examples available at https://threejs.org/examples/
     * and lectures at Aberystwyth University
     * adapted by me, Leon Hassan - leh28
     */
    var mouse_pos = new THREE.Vector2();

    function onMouseMove(event) {
      mouse_pos.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse_pos.y = -(event.clientY / window.innerHeight) * 2 + 1;
    }
    var raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(), 0, 10);
    scene.add(controls.getObject());
    ////////////////////////////////
    //ambient light
    //var ambient_light = new THREE.AmbientLight(0xffffff, 1);
    //
    //scene.add(ambient_light);
    ////////////////////////////////
    //LIGHTING
    ////////////////////////////////
    //garage_light_1
    var garage_light_1 = new THREE.SpotLight(0xffee88, 2, 25, 1); //SpotLight( color, intensity, distance, angle, penumbra, decay )
    garage_light_1.position.set(-25, 18, 160);
    garage_light_1.target.position.set(-25, 0, 160);
    garage_light_1.penumbra = 0.1;
    garage_light_1.castShadow = true;
    garage_light_1.target.updateMatrixWorld();
    scene.add(garage_light_1);
    //var garage_light_1_helper = new THREE.SpotLightHelper(garage_light_1);
    //scene.add(garage_light_1_helper);
    ////////////////////////////////
    //garage_light_2
    var garage_light_2 = new THREE.SpotLight(0xffee88, 1, 25, 1);
    garage_light_2.position.set(-25, 18, 185);
    garage_light_2.target.position.set(-25, 0, 185);
    garage_light_2.penumbra = 0.1;
    garage_light_2.castShadow = true;
    garage_light_2.target.updateMatrixWorld();
    scene.add(garage_light_2);
    //var garage_light_2_helper = new THREE.SpotLightHelper(garage_light_2);
    //garage_light_2_helper.update();
    //scene.add(garage_light_2_helper);
    ////////////////////////////////
    //dining_light_1 - kitchen wall
    var dining_light_1 = new THREE.SpotLight(0xffffff, 1, 30, 0.9, 0.5); //SpotLight( color, intensity, distance, angle, penumbra, decay )
    dining_light_1.position.set(-25, 18, 75);
    dining_light_1.target.position.set(-15, 10, 75);
    dining_light_1.castShadow = true;
    dining_light_1.target.updateMatrixWorld();
    dining_light_1.shadow.camera.near = 5;
    dining_light_1.shadow.camera.far = 200;
    scene.add(dining_light_1);
    //var dining_light_1_helper = new THREE.SpotLightHelper(dining_light_1);
    //scene.add(dining_light_1_helper);
    ////////////////////////////////
    //dining_light_2 - garage
    var dining_light_2 = new THREE.SpotLight(0xffffff, 1, 30, 0.9, 0.5);
    dining_light_2.position.set(-25, 18, 75);
    dining_light_2.target.position.set(-25, 0, 85);
    dining_light_2.castShadow = true;
    dining_light_2.target.updateMatrixWorld();
    dining_light_2.shadow.camera.near = 5;
    dining_light_2.shadow.camera.far = 200;
    scene.add(dining_light_2);
    //var dining_light_2_helper = new THREE.SpotLightHelper(dining_light_2);
    //scene.add(dining_light_2_helper);
    ////////////////////////////////
    //dining_light_3 - back of house wall
    var dining_light_3 = new THREE.SpotLight(0xffffff, 1, 30, 0.9, 0.5);
    dining_light_3.position.set(-25, 18, 75);
    dining_light_3.target.position.set(-35, 0, 75);
    dining_light_3.castShadow = true;
    dining_light_3.target.updateMatrixWorld();
    scene.add(dining_light_3);
    //var dining_light_3_helper = new THREE.SpotLightHelper(dining_light_3);
    //scene.add(dining_light_3_helper);
    ////////////////////////////////
    //dining_light_4 - living room
    var dining_light_4 = new THREE.SpotLight(0xffffff, 1, 30, 0.9, 0.5);
    dining_light_4.position.set(-25, 18, 75);
    dining_light_4.target.position.set(-25, 0, 65);
    dining_light_4.castShadow = true;
    dining_light_4.target.updateMatrixWorld();
    scene.add(dining_light_4);
    //var dining_light_4_helper = new THREE.SpotLightHelper(dining_light_4);
    //scene.add(dining_light_4_helper);
    ////////////////////////////////
    //kitchen_light_1
    var kitchen_light_1 = new THREE.PointLight(0xffffff, 0.75);
    kitchen_light_1.position.set(30, 16, 75);
    kitchen_light_1.castShadow = true;
    scene.add(kitchen_light_1);
    //var kitchen_light_1_helper = new THREE.PointLightHelper(kitchen_light_1);
    //scene.add(kitchen_light_1_helper);
    ////////////////////////////////
    //living_light_1
    var living_light_1 = new THREE.PointLight(0xffffff, 2, 100, 2);
    living_light_1.position.set(5, 16, -40);
    living_light_1.castShadow = true;
    scene.add(living_light_1);
    //var living_light_1_helper = new THREE.PointLightHelper(living_light_1);
    //scene.add(living_light_1_helper);
    ////////////////////////////////
    //END OF LIGHTING
    ////////////////////////////////
    ////////////////////////////////
    //BEGIN TEXTURES
    ////////////////////////////////
    var texture_loader = new THREE.TextureLoader();
    // ceiling texture
    // open resource, found at: http://3.bp.blogspot.com/-Fbzkv8Omxtc/T2HY2QU0Q4I/AAAAAAAABQw/40kHbheH3Ek/s1600/Seamless+wall+plaster+%25284%2529.jpg
    var ceiling_texture = texture_loader.load('tex/ceiling.jpg');
    ceiling_texture.wrapS = THREE.RepeatWrapping;
    ceiling_texture.wrapT = THREE.RepeatWrapping;
    ceiling_texture.repeat.set(10, 10);
    // wooden floor texture
    // open resource, found with table and chair object source files
    var wooden_floor_texture = texture_loader.load('tex/light-wood.jpg');
    wooden_floor_texture.wrapS = THREE.RepeatWrapping;
    wooden_floor_texture.wrapT = THREE.RepeatWrapping;
    wooden_floor_texture.repeat.set(15, 15);
    // wooden floor (doorway) texture
    var wooden_floor_2_texture = texture_loader.load('tex/light-wood.jpg');
    wooden_floor_2_texture.wrapS = THREE.RepeatWrapping;
    wooden_floor_2_texture.wrapT = THREE.RepeatWrapping;
    wooden_floor_2_texture.repeat.set(5, 5);
    // granite floor texture
    // open resource, found at: http://1.bp.blogspot.com/-Kn7M1W_Yh_k/U7FxDaDQRII/AAAAAAAAFbY/xqzejAoM94Y/s1600/(CONCRETE+16)+seamless+floor+granite+stones+texture.jpg
    var granite_floor_texture = texture_loader.load("tex/granite-stones.jpg");
    granite_floor_texture.wrapS = THREE.RepeatWrapping;
    granite_floor_texture.wrapT = THREE.RepeatWrapping;
    // plaster wall texture
    // open resource, found on the module blackboard area, under assignment
    var plaster_wall_texture = texture_loader.load("tex/plaster.jpg");
    plaster_wall_texture.wrapS = THREE.RepeatWrapping;
    plaster_wall_texture.wrapT = THREE.RepeatWrapping;
    // brick jpg was an open resource, found at: https://www.google.co.uk/url?sa=i&rct=j&q&esrc=s&source=images&cd&ved=0ahUKEwixvpnr99_QAhUCWxoKHS1zB3cQjBwIBA&url=http%3A%2F%2Fwww.cadhatch.com%2Fdownload%2Fi%2Fmark_dl%2Fu%2F4013003604%2F4618103753%2FBrick-2377.jpg&psig=AFQjCNH5Yx0FE9vHCBjwfscVl2o8v_-ugA&ust=1481126365155862
    // brick wall texture
    var brick_wall_texture = texture_loader.load("tex/bricks.jpg");
    brick_wall_texture.wrapS = THREE.RepeatWrapping;
    brick_wall_texture.wrapT = THREE.RepeatWrapping;
    brick_wall_texture.repeat.set(15, 2);
    // long brick wall texture
    var long_brick_wall_texture = texture_loader.load("tex/bricks.jpg");
    long_brick_wall_texture.wrapS = THREE.RepeatWrapping;
    long_brick_wall_texture.wrapT = THREE.RepeatWrapping;
    long_brick_wall_texture.repeat.set(12, 2);
    // med brick wall texture
    var med_brick_wall_texture = texture_loader.load("tex/bricks.jpg");
    med_brick_wall_texture.wrapS = THREE.RepeatWrapping;
    med_brick_wall_texture.wrapT = THREE.RepeatWrapping;
    med_brick_wall_texture.repeat.set(5, 2);
    // thin brick wall texture
    var thin_brick_wall_texture = texture_loader.load("tex/bricks.jpg");
    thin_brick_wall_texture.wrapS = THREE.RepeatWrapping;
    thin_brick_wall_texture.wrapT = THREE.RepeatWrapping;
    thin_brick_wall_texture.repeat.set(2, 2);
    ////////////////////////////////
    //END TEXTURES
    ////////////////////////////////
    ////////////////////////////////
    //BEGIN PLANES
    ////////////////////////////////
    // main floor plane
    var plane_geo = new THREE.PlaneGeometry(100, 200, 0);
    var plane_mat = new THREE.MeshPhongMaterial({
      map: wooden_floor_texture,
      side: THREE.DoubleSide
    });
    var main_floor = new THREE.Mesh(plane_geo, plane_mat);
    main_floor.rotation.x = (Math.PI * (90 / 180));
    main_floor.recieveShadows = true;
    // main roof
    var roof_geo = new THREE.PlaneGeometry(100, 200, 0);
    var roof_mat = new THREE.MeshPhongMaterial({
      map: ceiling_texture,
      side: THREE.DoubleSide
    });
    var main_roof = new THREE.Mesh(roof_geo, roof_mat);
    main_roof.rotation.x = (Math.PI * (90 / 180));
    main_roof.position.set(0, 20, 0);
    main_roof.recieveShadows = true;
    ////////////////////////////////
    // house entrance plane
    var plane_geo_2 = new THREE.PlaneGeometry(50, 50, 0);
    var plane_mat_2 = new THREE.MeshPhongMaterial({
      map: wooden_floor_2_texture,
      side: THREE.DoubleSide
    });
    var porch_floor = new THREE.Mesh(plane_geo_2, plane_mat_2);
    porch_floor.rotation.x = (Math.PI * (90 / 180));
    //porch_floor.rotation.z = (Math.PI * (90 / 180));
    porch_floor.position.set(-25, 0, 125);
    porch_floor.recieveShadows = true;
    // house entrance roof
    var roof_geo_2 = new THREE.PlaneGeometry(50, 50, 0);
    var roof_mat_2 = new THREE.MeshPhongMaterial({
      map: ceiling_texture,
      side: THREE.DoubleSide
    });
    var porch_roof = new THREE.Mesh(roof_geo_2, roof_mat_2);
    porch_roof.rotation.x = (Math.PI * (90 / 180));
    porch_roof.rotation.z = (Math.PI * (90 / 180));
    porch_roof.position.set(-25, 20, 125);
    porch_roof.recieveShadows = true;
    ////////////////////////////////
    // garage plane
    var plane_geo_3 = new THREE.PlaneGeometry(50, 50, 0);
    var plane_mat_3 = new THREE.MeshPhongMaterial({
      map: granite_floor_texture,
      side: THREE.DoubleSide
    });
    var garage_floor = new THREE.Mesh(plane_geo_3, plane_mat_3);
    garage_floor.rotation.x = (Math.PI * (90 / 180));
    garage_floor.rotation.z = (Math.PI * (90 / 180));
    garage_floor.position.set(-25, 0, 175);
    garage_floor.recieveShadows = true;
    // garage plane
    var roof_geo_3 = new THREE.PlaneGeometry(50, 50, 0);
    var roof_mat_3 = new THREE.MeshPhongMaterial({
      color: 0x0000ff,
      side: THREE.DoubleSide
    });
    var garage_roof = new THREE.Mesh(roof_geo_3, roof_mat_3);
    garage_roof.rotation.x = (Math.PI * (90 / 180));
    garage_roof.rotation.z = (Math.PI * (90 / 180));
    garage_roof.position.set(-25, 20, 175);
    garage_roof.recieveShadows = true;
    ////////////////////////////////
    // garden patio plane
    var plane_geo_4 = new THREE.PlaneGeometry(50, 100, 0);
    var plane_mat_4 = new THREE.MeshPhongMaterial({
      color: 0x00ff00,
      side: THREE.DoubleSide
    });
    var garden_floor_1 = new THREE.Mesh(plane_geo_4, plane_mat_4);
    garden_floor_1.rotation.x = (Math.PI * (90 / 180));
    garden_floor_1.rotation.z = (Math.PI * (90 / 180));
    garden_floor_1.position.set(0, 0, -125);
    garden_floor_1.recieveShadows = true;
    //add all planes to the scene
    scene.add(main_floor);
    scene.add(main_roof);
    scene.add(porch_floor);
    scene.add(porch_roof);
    scene.add(garage_floor);
    scene.add(garage_roof);
    scene.add(garden_floor_1);
    ////////////////////////////////
    //END PLANES
    ////////////////////////////////
    ////////////////////////////////////////
    //BEGIN WALLS
    ////////////////////////////////////////
    //set up wall constants
    var wall_height = 25;
    var wall_mat = new THREE.MeshPhongMaterial({
      map: plaster_wall_texture,
      transparent: false
    });
    //set up arrays of materials so that I can place different textures on the inner and outer faces
    var north_wall_materials = new THREE.MeshFaceMaterial([
      new THREE.MeshPhongMaterial({
        map: plaster_wall_texture
      })
      , new THREE.MeshPhongMaterial({
        map: brick_wall_texture
      })
      , new THREE.MeshPhongMaterial({
        map: plaster_wall_texture
      })
      , new THREE.MeshPhongMaterial({
        map: plaster_wall_texture
      })
      , new THREE.MeshPhongMaterial({
        map: plaster_wall_texture
      })
      , new THREE.MeshPhongMaterial({
        map: plaster_wall_texture
      })
    ]);
    var south_wall_materials = new THREE.MeshFaceMaterial([
      new THREE.MeshPhongMaterial({
        map: med_brick_wall_texture
      })
      , new THREE.MeshPhongMaterial({
        map: plaster_wall_texture
      })
      , new THREE.MeshPhongMaterial({
        map: plaster_wall_texture
      })
      , new THREE.MeshPhongMaterial({
        map: plaster_wall_texture
      })
      , new THREE.MeshPhongMaterial({
        map: plaster_wall_texture
      })
      , new THREE.MeshPhongMaterial({
        map: plaster_wall_texture
      })
    ]);
    var wide_south_wall_materials = new THREE.MeshFaceMaterial([
      new THREE.MeshPhongMaterial({
        map: long_brick_wall_texture
      })
      , new THREE.MeshPhongMaterial({
        map: plaster_wall_texture
      })
      , new THREE.MeshPhongMaterial({
        map: plaster_wall_texture
      })
      , new THREE.MeshPhongMaterial({
        map: plaster_wall_texture
      })
      , new THREE.MeshPhongMaterial({
        map: plaster_wall_texture
      })
      , new THREE.MeshPhongMaterial({
        map: plaster_wall_texture
      })
    ]);
    var thin_south_wall_materials = new THREE.MeshFaceMaterial([
      new THREE.MeshPhongMaterial({
        map: thin_brick_wall_texture
      })
      , new THREE.MeshPhongMaterial({
        map: plaster_wall_texture
      })
      , new THREE.MeshPhongMaterial({
        map: plaster_wall_texture
      })
      , new THREE.MeshPhongMaterial({
        map: plaster_wall_texture
      })
      , new THREE.MeshPhongMaterial({
        map: plaster_wall_texture
      })
      , new THREE.MeshPhongMaterial({
        map: plaster_wall_texture
      })
    ]);
    var west_wall_materials = new THREE.MeshFaceMaterial([
      new THREE.MeshPhongMaterial({
        map: plaster_wall_texture
      })
      , new THREE.MeshPhongMaterial({
        map: med_brick_wall_texture
      })
      , new THREE.MeshPhongMaterial({
        map: plaster_wall_texture
      })
      , new THREE.MeshPhongMaterial({
        map: plaster_wall_texture
      })
      , new THREE.MeshPhongMaterial({
        map: plaster_wall_texture
      })
      , new THREE.MeshPhongMaterial({
        map: plaster_wall_texture
      })
    ]);
    /* Shadows for some reason were not working in my project, even when
     * compared to friends we could see nothing wrong with my setup for shadows.
     * I spoke with Helen Miles and was told not to worry, it was a fault with
     * Three.js and that it was a known issue
     */
    ////////////////////////////////////////
    //wall 1 - front of house
    var wall_geo_1 = new THREE.BoxGeometry(0.1, wall_height, 60);
    var wall_1 = new THREE.Mesh(wall_geo_1, south_wall_materials);
    /* I made the walls slightly taller than needed so that they would intersect the
     * planes that made up the roof and floor, this was an attempt to stop light going
     * under and over the walls
     */
    wall_1.position.set(0, 10, 170);
    wall_1.castShadow = true;
    wall_1.recieveShadows = true;
    scene.add(wall_1);
    ////////////////////////////////////////
    //wall 2 - back of garage
    var wall_geo_2 = new THREE.BoxGeometry(0.1, wall_height, 50);
    var wall_2 = new THREE.Mesh(wall_geo_2, west_wall_materials);
    wall_2.rotation.y = (Math.PI * (90 / 180));
    wall_2.position.set(-25, 10, 200);
    wall_2.castShadow = true;
    wall_2.recieveShadows = true;
    scene.add(wall_2);
    ////////////////////////////////////////
    //wall 3 - back of house
    var wall_geo_3 = new THREE.BoxGeometry(0.1, wall_height, 300);
    var wall_3 = new THREE.Mesh(wall_geo_3, north_wall_materials);
    wall_3.position.set(-50, 10, 50);
    wall_3.castShadow = true;
    wall_3.recieveShadows = true;
    scene.add(wall_3);
    ////////////////////////////////////////
    //wall 4 - front of house cont.
    var wall_geo_4 = new THREE.BoxGeometry(0.1, wall_height, 20);
    var wall_4 = new THREE.Mesh(wall_geo_4, thin_south_wall_materials);
    wall_4.position.set(0, 10, 110);
    wall_4.castShadow = true;
    wall_4.recieveShadows = true;
    scene.add(wall_4);
    ////////////////////////////////////////
    //wall 5 - front of garage
    var wall_geo_5 = new THREE.BoxGeometry(0.1, wall_height, 20);
    var wall_5 = new THREE.Mesh(wall_geo_5, wall_mat);
    wall_5.rotation.y = (Math.PI * (90 / 180));
    wall_5.position.set(-10, 10, 150);
    wall_5.castShadow = true;
    wall_5.recieveShadows = true;
    scene.add(wall_5);
    ////////////////////////////////////////
    //wall 6 - front of garage cont
    var wall_geo_6 = new THREE.BoxGeometry(0.1, wall_height, 20);
    var wall_6 = new THREE.Mesh(wall_geo_6, wall_mat);
    wall_6.rotation.y = (Math.PI * (90 / 180));
    wall_6.position.set(-40, 10, 150);
    wall_6.castShadow = true;
    wall_6.recieveShadows = true;
    scene.add(wall_6);
    ////////////////////////////////////////
    //wall 7 - front of house, kitchen wall
    var wall_geo_7 = new THREE.BoxGeometry(0.1, wall_height, 50);
    var wall_7 = new THREE.Mesh(wall_geo_7, west_wall_materials);
    wall_7.rotation.y = (Math.PI * (90 / 180));
    wall_7.position.set(25, 10, 100);
    wall_7.castShadow = true;
    wall_7.recieveShadows = true;
    scene.add(wall_7);
    ////////////////////////////////////////
    //wall 8 - side of house, dining and living room walls (long wall)
    var wall_geo_8 = new THREE.BoxGeometry(0.1, wall_height, 200);
    var wall_8 = new THREE.Mesh(wall_geo_8, wide_south_wall_materials);
    wall_8.position.set(50, 10, 0);
    wall_8.castShadow = true;
    wall_8.recieveShadows = true;
    scene.add(wall_8);
    ////////////////////////////////////////
    //wall 9 - house-to-garden wall
    var wall_geo_9 = new THREE.BoxGeometry(0.1, wall_height, 70);
    var wall_9 = new THREE.Mesh(wall_geo_9, south_wall_materials);
    wall_9.rotation.y = (Math.PI * (90 / 180));
    wall_9.position.set(15, 10, -100);
    wall_9.castShadow = true;
    wall_9.recieveShadows = true;
    scene.add(wall_9);
    ////////////////////////////////////////
    //wall 10 - living room-to-kitchen wall
    var wall_geo_10 = new THREE.BoxGeometry(0.1, wall_height, 50);
    var wall_10 = new THREE.Mesh(wall_geo_10, wall_mat);
    wall_10.position.set(10, 10, 75);
    wall_10.castShadow = true;
    wall_10.recieveShadows = true;
    scene.add(wall_10);
    ////////////////////////////////////////
    //wall 11 - living room-to-kitchen wall cont
    var wall_geo_11 = new THREE.BoxGeometry(0.1, wall_height, 20);
    var wall_11 = new THREE.Mesh(wall_geo_11, wall_mat);
    wall_11.position.set(10, 10, 25);
    wall_11.castShadow = true;
    wall_11.recieveShadows = true;
    scene.add(wall_11);
    ////////////////////////////////////////
    //wall 12 - front of house, kitchen wall
    var wall_geo_12 = new THREE.BoxGeometry(0.1, wall_height, 70);
    var wall_12 = new THREE.Mesh(wall_geo_12, wall_mat);
    wall_12.rotation.y = (Math.PI * (90 / 180));
    wall_12.position.set(15, 10, 15);
    wall_12.castShadow = true;
    wall_12.recieveShadows = true;
    scene.add(wall_12);
    ////////////////////////////////////////
    //END OF WALLS
    ////////////////////////////////////////
    ////////////////////////////////////////
    //BEGIN DOORWAY CURTAIN
    ////////////////////////////////////////
    /* My doorway curtain is based largely the Cloth example, available on the Three.js
     * examples, found at: https://threejs.org/examples/#webgl_animation_cloth
     * 
     * adapted by me, Leon Hassan - leh28
     */
    //the pins are what hold the curtain in place, the number of attaching points for the curtain
    var pinsFormation = [];
    var pins = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    pinsFormation.push(pins);
    // cloth material
    // texture jpg is an open resource, found at: https://vwartclub.com/media/learning/making-of-scandinavian-interior/21.jpg
    var clothTexture = texture_loader.load('tex/curtain.jpg');
    clothTexture.wrapS = clothTexture.wrapT = THREE.RepeatWrapping;
    clothTexture.anisotropy = 16;
    var clothMaterial = new THREE.MeshPhongMaterial({
      specular: 0x030303,
      map: clothTexture,
      side: THREE.DoubleSide,
      alphaTest: 0.5
    });
    // cloth geometry
    clothGeometry = new THREE.ParametricGeometry(clothFunction, cloth.w, cloth.h);
    clothGeometry.dynamic = true;
    var uniforms = {
      texture: {
        value: clothTexture
      }
    };
    var vertexShader = document.getElementById('vertexShaderDepth').textContent;
    var fragmentShader = document.getElementById('fragmentShaderDepth').textContent;
    // cloth mesh
    object = new THREE.Mesh(clothGeometry, clothMaterial);
    object.position.set(-35, 7, 15);
    object.scale.set(0.1, 0.1, 0.01);
    object.castShadow = true;
    scene.add(object);
    object.customDepthMaterial = new THREE.ShaderMaterial({
      uniforms: uniforms,
      vertexShader: vertexShader,
      fragmentShader: fragmentShader,
      side: THREE.DoubleSide
    });
    ////////////////////////////////////////
    //END DOORWAY CURTAIN
    ////////////////////////////////////////
    ////////////////////////////////////////
    //BEGIN OBJECTS
    ////////////////////////////////////////
    var mtlLoader = new THREE.MTLLoader();
    // lightswitch
    // open resource, found at: http://tf3dm.com/3d-model/light-switch-22023.html
    mtlLoader.load("obj/lightswitch/lightswitch.mtl", function (materials) {
      materials.preload();
      var objLoader = new THREE.OBJLoader();
      objLoader.setMaterials(materials);
      objLoader.load("obj/lightswitch/lightswitch.obj", function (object) {
        object.position.set(-40, 10, 150);
        object.rotation.x = (Math.PI * (270 / 180));
        object.rotation.z = (Math.PI * (180 / 180));
        object.scale.set(20, 20, 20);
        object.castShadow = true;
        object.name = "lightswitch";
        scene.add(object);
        object.traverse(function (obj) {
          if (obj instanceof THREE.Mesh) {
            obj.receiveShadow = true;
            obj.castShadow = true;
            obj.geometry.computeVertexNormals();
            objects.push(obj);
          }
        })
      });
    });
    // fireplace
    mtlLoader.load("obj/fireplace/fireplace.mtl", function (materials) {
      materials.preload();
      var objLoader = new THREE.OBJLoader();
      objLoader.setMaterials(materials);
      objLoader.load("obj/fireplace/fireplace.obj", function (object) {
        object.position.set(5, 0.5, -92.5);
        object.rotation.y = (Math.PI * (360 / 180));
        object.scale.set(2, 2, 2);
        object.castShadow = true;
        object.name = "fireplace";
        scene.add(object);
        object.traverse(function (obj) {
          if (obj instanceof THREE.Mesh) {
            obj.receiveShadow = true;
            obj.castShadow = true;
            obj.geometry.computeVertexNormals();
            objects.push(obj);
          }
        })
      });
    });
    // living light shade
    mtlLoader.load("obj/bulb/bigger_lampshade.mtl", function (materials) {
      materials.preload();
      var objLoader = new THREE.OBJLoader();
      objLoader.setMaterials(materials);
      objLoader.load("obj/bulb/bigger_lampshade.obj", function (object) {
        object.position.set(5, 15, -40);
        object.scale.set(1, 1, 1);
        object.castShadow = true;
        object.name = "desk";
        scene.add(object);
        object.traverse(function (obj) {
          if (obj instanceof THREE.Mesh) {
            obj.receiveShadow = true;
            obj.castShadow = true;
            obj.geometry.computeVertexNormals();
            objects.push(obj);
          }
        })
      });
    });
    // light bulb
    mtlLoader.load("obj/bulb/dangle-bulb.mtl", function (materials) {
      materials.preload();
      var objLoader = new THREE.OBJLoader();
      objLoader.setMaterials(materials);
      objLoader.load("obj/bulb/dangle-bulb.obj", function (object) {
        object.rotation.x = (Math.PI * (180 / 180));
        object.scale.set(0.25, 0.25, 0.25);
        object.position.set(5, 18, -40); //living_1
        object.castShadow = true;
        object.name = "bulb";
        scene.add(object);
        /* Instead of loading the material mutliple times, I load it once and
         * then clone the material to produce multiple meshes from the same instance
         * of the material.
         * 
         * I did this to cut down loading times with objects that were being used
         * repeatedly.
         */
        var my_hanging_bulbs = [object.clone(), object.clone(), object.clone()]
        my_hanging_bulbs[0].position.set(-25, 18, 160); //garage_1
        my_hanging_bulbs[1].position.set(-25, 18, 185); //garage_2
        my_hanging_bulbs[2].position.set(30, 18, 75); //kitchen_1
        for (var i = 0; i < my_hanging_bulbs.length; i++) {
          my_hanging_bulbs[i].name += [i];
          scene.add(my_hanging_bulbs[i]);
          my_hanging_bulbs[i].traverse(function (obj) {
            if (obj instanceof THREE.Mesh) {
              obj.receiveShadow = true;
              obj.castShadow = true;
              obj.geometry.computeVertexNormals();
              objects.push(obj);
            }
          })
        }
      });
    });
    //sofa
    mtlLoader.load("obj/sofa/sofa.mtl", function (materials) {
      materials.preload();
      var objLoader = new THREE.OBJLoader();
      objLoader.setMaterials(materials);
      objLoader.load("obj/sofa/sofa.obj", function (object) {
        object.position.set(-10, 0, -80);
        object.rotation.y = (Math.PI * (90 / 180));
        object.castShadow = true;
        object.name = "sofa";
        scene.add(object);
        object.traverse(function (obj) {
          if (obj instanceof THREE.Mesh) {
            obj.receiveShadow = true;
            obj.castShadow = true;
            obj.geometry.computeVertexNormals();
            objects.push(obj);
          }
        })
      });
    });
    //foot stool
    mtlLoader.load("obj/footstool/footstool.mtl", function (materials) {
      materials.preload();
      var objLoader = new THREE.OBJLoader();
      objLoader.setMaterials(materials);
      objLoader.load("obj/footstool/footstool.obj", function (object) {
        //object.position.set(-10, 0, -50);
        object.position.set(0, 0, -80);
        object.rotation.y = (Math.PI * (90 / 180));
        object.scale.set(1.5, 1.5, 1.5);
        object.castShadow = true;
        object.name = "foot stool";
        scene.add(object);
        object.traverse(function (obj) {
          if (obj instanceof THREE.Mesh) {
            obj.receiveShadow = true;
            obj.castShadow = true;
            obj.geometry.computeVertexNormals();
            objects.push(obj);
          }
        })
      });
    });
    //dining room table
    //open resource, taken from: http://archive3d.net/?a=download&id=a0e41e46
    mtlLoader.load("obj/table/table.mtl", function (materials) {
      materials.preload();
      var objLoader = new THREE.OBJLoader();
      objLoader.setMaterials(materials);
      objLoader.load("obj/table/table.obj", function (object) {
        object.position.set(0, 0, 0);
        object.scale.set(0.25, 0.25, 0.25);
        object.castShadow = true;
        object.name = "table";
        scene.add(object);
        object.traverse(function (obj) {
          if (obj instanceof THREE.Mesh) {
            obj.receiveShadow = true;
            obj.castShadow = true;
            obj.geometry.computeVertexNormals();
            objects.push(obj);
          }
        })
      });
    });
    //dining room chair
    //open resource, taken from: http://archive3d.net/?a=download&id=44514591
    mtlLoader.load("obj/chair/chair.mtl", function (materials) {
      materials.preload();
      var objLoader = new THREE.OBJLoader();
      objLoader.setMaterials(materials);
      objLoader.load("obj/chair/chair.obj", function (object) {
        object.position.set(10, 0, 5);
        object.scale.set(0.25, 0.25, 0.25);
        object.castShadow = true;
        object.name = "chair";
        scene.add(object);
        var my_chairs = [object.clone(), object.clone(), object.clone()]
        my_chairs[0].position.set(10, 0, -5);
        my_chairs[1].position.set(-5, 0, 5);
        my_chairs[1].rotation.y = (Math.PI * (180 / 180));
        my_chairs[2].position.set(-5, 0, -5);
        my_chairs[2].rotation.y = (Math.PI * (180 / 180));
        for (var i = 0; i < my_chairs.length; i++) {
          my_chairs[i].name += [i];
          scene.add(my_chairs[i]);
          my_chairs[i].traverse(function (obj) {
            if (obj instanceof THREE.Mesh) {
              obj.receiveShadow = true;
              obj.castShadow = true;
              obj.geometry.computeVertexNormals();
              objects.push(obj);
            }
          })
        }
      });
    });
    ////////////////////////////////////////
    //END OBJECTS
    ////////////////////////////////////////
    // add event listener for resizing the window
    window.addEventListener('resize', onWindowResize, false);

    // re-initialise function, that is called on window resize
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function render() {
      renderer.render(scene, camera);
      requestAnimationFrame(render);
      var time = Date.now();
      //fire rendering
      particleSystem.rotation.z = 0.01 * (time * 0.005);
      var sizes = geometry.attributes.size.array;
      for (var i = 0; i < particles; i++) {
        sizes[i] = (1 + Math.sin(0.1 * i + (time * 0.005)));
      }
      geometry.attributes.size.needsUpdate = true;
      // doorway curtain rendering
      /* windStrength is a linearly increasing constant which is used with a variety
       * of wave functions and set as windForce, this will linearly increase the speed
       * of the wind affecting the doorway curtain
      */
      windStrength = Math.cos(time / 7000) * 20 + 40;
      windForce.set(Math.sin(time / 2000), Math.cos(time / 3000), Math.sin(time / 1000)).normalize().multiplyScalar(windStrength);
      simulate(time);
      //using Cloth.js functions to accurately model particles for the doorway curtain
      var p = cloth.particles;
      for (var i = 0, il = p.length; i < il; i++) {
        clothGeometry.vertices[i].copy(p[i].position);
      }
      clothGeometry.computeFaceNormals();
      clothGeometry.computeVertexNormals();
      clothGeometry.normalsNeedUpdate = true;
      clothGeometry.verticesNeedUpdate = true;
      if (controlsEnabled) {
        //if controls are enabled we are in-focus
        raycaster.ray.origin.copy(controls.getObject().position);
        raycaster.ray.origin.y -= 10;
        raycaster.ray.direction.set(controls.getObject().rotation.y);
        raycaster.setFromCamera(mouse_pos, camera);
        var bump_list = [];
        bump_list = raycaster.intersectObjects(objects);
        for (var i = 0; i < bump_list.length; i++) {
          //if we are in-range of an object it is added to the bump_list
          if (bump_list[i].object.name.includes('switchbase')) {
            //if the list contains something that we have interaction with, filtering by object name
            if (INTERACT) {
              //if we are trying to interact with something, we will flip the visibility of each garage light and then reset the INTERACT var
              garage_light_1.visible = garage_light_1.visible ? false : true
              garage_light_2.visible = garage_light_2.visible ? false : true
              INTERACT = false;
            }
          }
        }
        var time = performance.now();
        var delta = (time - prevTime) / 1000;
        velocity.x -= velocity.x * 10.0 * delta;
        velocity.z -= velocity.z * 10.0 * delta;
        velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass
        if (moveForward) velocity.z -= 400.0 * delta;
        if (moveBackward) velocity.z += 400.0 * delta;
        if (moveLeft) velocity.x -= 400.0 * delta;
        if (moveRight) velocity.x += 400.0 * delta;
        controls.getObject().translateX(velocity.x * delta);
        controls.getObject().translateY(velocity.y * delta);
        controls.getObject().translateZ(velocity.z * delta);
        if (controls.getObject().position.y < 10) {
          velocity.y = 0;
          controls.getObject().position.y = 10;
        }
        prevTime = time;
      }
      renderer.render(scene, camera);
    }
    render();
  </script>
</body>

</html>